Questa repository contiene un PE Debugger per Microsoft Windows. Un progetto ad albero, che comprende 2 main file:

1. *static.py*: Questo esegue l'analisi statica di un PE. Analizzando un .EXE con questo strumento, verrà salvato un file chiamato "debug_log.txt" nello stesso percorso ove risiede lo script, con le seguenti informazioni: architettura dell'exe (x86/x64), informazioni e verifica dello stato delle sezioni, indirizzi e-mail/IP/URL/Random keys associati al template, specifiche sulla compatibilità dell'app (ad esempio se è un'app ad interfaccia grafica o che si interfaccia con il terminal, che nel caso di Windows è cmd.exe, e indica anche se l'app supporta gli standard POSIX), informazioni sulle .DLL importate dall'.EXE, versione del Linker ed altre risorse.

2. *memdump.py*: Questa doveva essere la parte più ambiziosa del progetto, ma a causa della difficoltà legata alle documentazioni, è stato molto difficile sviluppare un debugger-runtime che risponde alle pratiche igieniche del reverse engineering. Anzitutto informo i visitatori che questo debugger ha una vulnerabilità di tipo "OS command injection", in quanto il debugger non incorpora una sandbox. Di conseguenza tutti i file che vengono eseguiti da esso, saranno eseguiti sull'OS sottostante piuttosto che in una sandbox, creando un rischio concreto per la sicurezza. Raccomando il test di questo programma in un ambiente isolato a parte (come VMware). Tempo fa conobbi un progetto su Github chiamato "pysandbox" che fu un fallimento, quindi almeno non mi sento l'unico ad aver avuto difficoltà a creare una sandbox per questo debugger. Il runtime-debugger svolge i seguenti task: Esegue il PE indicato, rilevandone il PID grazie alla funzione "get_process_id", legge la memoria del processo e ne esegue il dumping, salvando il contenuto in formato binary in un file di testo. In seguito monitora le risorse della CPU richieste dal processo, ed eventuali endpoint a cui cerca di connettersi. Grazie a due tool gratuiti di Microsoft Sysinternal (e di cui dovrete accettare l'EULA prima di eseguirli, altrimenti il debugger fallirà) ho aggiunto all'artefatto la capacità di fare parsing e decoding di quante più stringhe possibili dal codice binario. Sigcheck invece, sta qui per individuare le caratteristiche legate alle firme digitali del file, verificandone l'integrità. L'aspetto della sicurezza del file, mi concerne fondamentalmente, quindi mi preme specificare nuovamente che c'è una vulnerabilità di tipo "OS command injection" nel tool: di conseguenza, qualora vorrai testarlo per studiare i malware, ti raccomando caldamente di farlo su VMWare, o comunque in un ambiente isolato. Qualora qualsiasi cosa vada storta durante il debugging, ho aggiunto la capacità di quittare forzatamente sia il thread del debugger che il thread "figlio" semplicemente con CTRL+C. Attualmente funziona abbastanza bene, ma per qualche ragione non riesce a fare il debugging di tutti gli .EXE (in alcuni casi si inceppa).

3. Per la creazione di questo progetto mi sono ispirato ad un programma chiamato Process Hacker, con l'intenzione di comprendere le basi dell'ingegneria inversa. Per eseguire gli script correttamente è necessario installare i requisiti attraverso "pip install -r requirements.txt", e possedere Python 3. Nel mio caso, ho usato Python 3.12 per la creazione del progetto.
